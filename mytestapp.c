#include <furi.h>

#include <furi_hal.h>
#include <furi_hal_pwm.h>

#include <gui/gui.h>

#include <notification/notification.h>
#include <notification/notification_messages.h>

/* generated by fbt from .png files in images folder */
#include <mytestapp_icons.h>

const GpioPin* const pin_6 = &gpio_ext_pa6; // PIN A6
const GpioPin* const pin_7 = &gpio_ext_pa7; // PIN A7

#define DISPLAY_WIDTH 128
#define DISPLAY_HEIGHT 64

typedef enum {
    MyEventTypeKey,
    MyEventTypeDone,
} MyEventType;

typedef struct {
    MyEventType type; // The reason for this event.
    InputEvent input; // This data is specific to keypress data.
} MyEvent;

typedef struct {
    // Cursor coordinates
    int x;
    int y;

    // Direction of movement
    int xDirection;
    int yDirection;

    // Timer
    int timer;
    bool isRunning;

    // Time of run (ms)
    int time;
} TestAppState;

typedef struct {
    FuriMessageQueue* queue; // Event queue
    FuriTimer* timer; // Timer for redrawing the screen
    NotificationApp* notifications; // Used for controlling the backlight
    ViewPort* view_port; // Input and draw callbacks
    Gui* gui; // Fullscreen view

    TestAppState state; // Application data
} TestApp;

static void set_pin_states(bool isOn) {
    furi_hal_gpio_write(pin_6, !isOn);
    furi_hal_gpio_write(pin_7, isOn);
}

static void my_draw_callback(Canvas* canvas, void* context) {
    furi_assert(context);
    TestApp* app = (TestApp*)context;

    char str_timer[11];
    itoa(app->state.timer, str_timer, 10);
    char str_x[11];
    itoa(app->state.x, str_x, 10);
    char str_y[11];
    itoa(app->state.y, str_y, 10);

    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str(canvas, 5, 30, "Ahoj!");
    canvas_draw_str(canvas, 5, 40, "T:");
    canvas_draw_str(canvas, 17, 40, str_timer);
    canvas_draw_str(canvas, 5, 50, "X:");
    canvas_draw_str(canvas, 17, 50, str_x);
    canvas_draw_str(canvas, 45, 50, "Y:");
    canvas_draw_str(canvas, 57, 50, str_y);
    canvas_draw_str(canvas, app->state.x - 2, app->state.y + 8, "^");
}

static void my_input_callback(InputEvent* input_event, void* context) {
    furi_assert(context);
    TestApp* app = (TestApp*)context;

    if(input_event->type == InputTypeShort) {
        if(input_event->key == InputKeyOk) {
            app->state.isRunning = !app->state.isRunning;
            set_pin_states(app->state.isRunning);
        }
        if(input_event->key == InputKeyBack) {
            MyEvent event;
            event.type = MyEventTypeDone;
            furi_message_queue_put(app->queue, &event, FuriWaitForever);
        }
    } else if(input_event->type == InputTypePress) {
        if(input_event->key == InputKeyLeft) app->state.xDirection = -1;
        if(input_event->key == InputKeyRight) app->state.xDirection = 1;
        if(input_event->key == InputKeyUp) app->state.yDirection = -1;
        if(input_event->key == InputKeyDown) app->state.yDirection = 1;
    } else if(input_event->type == InputTypeRelease) {
        if(input_event->key == InputKeyLeft || input_event->key == InputKeyRight) {
            app->state.xDirection = 0;
        }
        if(input_event->key == InputKeyUp || input_event->key == InputKeyDown) {
            app->state.yDirection = 0;
        }
    }
}

static void timer_callback(void* context) {
    furi_assert(context);
    TestApp* app = (TestApp*)context;

    if(app->state.time % 60 == 0) {
        app->state.x = app->state.x + app->state.xDirection;
        app->state.y = app->state.y + app->state.yDirection;

        if(app->state.x > DISPLAY_WIDTH) app->state.x = DISPLAY_WIDTH;
        if(app->state.x < 0) app->state.x = 0;
        if(app->state.y > DISPLAY_HEIGHT) app->state.y = DISPLAY_HEIGHT;
        if(app->state.y < 0) app->state.y = 0;
    }

    if(app->state.isRunning) {
        app->state.timer += 10;
    }
    app->state.time += 10;
}

int32_t mytestapp_app(void* p) {
    UNUSED(p);

    // ---------------
    //      Init
    // ---------------
    TestApp* app = (TestApp*)malloc(sizeof(TestApp));

    // Create event queue
    app->queue = furi_message_queue_alloc(8, sizeof(MyEvent));

    // Create view port
    app->view_port = view_port_alloc();
    view_port_draw_callback_set(app->view_port, my_draw_callback, app);
    view_port_input_callback_set(app->view_port, my_input_callback, app);
    view_port_set_orientation(app->view_port, ViewPortOrientationHorizontal);

    // Create gui
    app->gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(app->gui, app->view_port, GuiLayerFullscreen);

    // Create timer
    app->timer = furi_timer_alloc(timer_callback, FuriTimerTypePeriodic, app);
    furi_timer_start(app->timer, 10);

    // Enforce backlight on
    app->notifications = furi_record_open(RECORD_NOTIFICATION);
    notification_message(app->notifications, &sequence_display_backlight_enforce_on);

    // Initialize the LED pins as output
    furi_hal_gpio_init_simple(pin_6, GpioModeOutputPushPull);
    furi_hal_gpio_init_simple(pin_7, GpioModeOutputPushPull);

    // ---------------
    //      Setup
    // ---------------
    app->state.x = 2;
    app->state.y = 5;
    app->state.xDirection = 0;
    app->state.yDirection = 0;
    app->state.time = 0;
    app->state.isRunning = false;
    set_pin_states(app->state.isRunning);

    // ---------------
    //    Main loop
    // ---------------
    MyEvent event;
    while(true) {
        if(furi_message_queue_get(app->queue, &event, FuriWaitForever) == FuriStatusOk) {
            if(event.type == MyEventTypeDone) {
                break;
            }
        } else {
            break;
        }
    }

    // ---------------
    //     Cleanup
    // ---------------

    // Typically when a pin is no longer in use, it is set to analog mode.
    furi_hal_gpio_init_simple(pin_6, GpioModeAnalog);
    furi_hal_gpio_init_simple(pin_7, GpioModeAnalog);

    // Set backlight back to auto
    notification_message(app->notifications, &sequence_display_backlight_enforce_auto);

    // Free resources
    furi_timer_free(app->timer);
    furi_message_queue_free(app->queue);
    view_port_enabled_set(app->view_port, false);
    gui_remove_view_port(app->gui, app->view_port);
    view_port_free(app->view_port);
    furi_record_close(RECORD_NOTIFICATION);
    furi_record_close(RECORD_GUI);
    free(app);

    return 0;
}
